# main_exploit_logic.py (Unified CLI Bot with Treys and Enhanced EV Tree + Bugfixes + Real Data Hook)
import pandas as pd
import pickle
import numpy as np
import re
import json
from sklearn.preprocessing import LabelEncoder
import xgboost as xgb
import matplotlib.pyplot as plt

try:
    from treys import Card, Evaluator
    evaluator = Evaluator()
    USE_TREYS = True
except ImportError:
    USE_TREYS = False

# --- EV Rollout Logic ---
def rollout_ev(pred_probs, hero_strength, pot_size, bet_size, samples=100):
    actions = ['f', 'cc', 'cbr']
    evs = []
    for _ in range(samples):
        action = np.random.choice(actions, p=pred_probs)
        if action == 'f':
            ev = 0.0
        elif action == 'cc':
            ev = (pot_size + bet_size) * hero_strength - bet_size * (1 - hero_strength)
        else:
            ev = -bet_size
        evs.append(ev)
    return np.mean(evs)

# --- Strategy Tree Simulation ---
def simulate_strategy_tree(state, model, depth=1, max_depth=3, ev_trace=None):
    if depth > max_depth:
        return 0.0

    input_df = pd.DataFrame([state])
    pred_probs = model.predict(input_df)[0]

    actions = ['f', 'cc', 'cbr']
    evs = {}
    for i, action in enumerate(actions):
        if action == 'f':
            ev = 0.0
        elif action == 'cc':
            new_pot = state["pot_size"] + state["bet_size"]
            next_state = state.copy()
            next_state["pot_size"] = new_pot
            next_state["effective_stack"] -= state["bet_size"]
            ev = (new_pot * state["hero_strength"] + simulate_strategy_tree(next_state, model, depth+1, max_depth, ev_trace)) * float(pred_probs[i])
        elif action == 'cbr':
            new_bet = state["pot_size"] * 0.75
            new_pot = state["pot_size"] + new_bet
            next_state = state.copy()
            next_state["pot_size"] = new_pot
            next_state["effective_stack"] -= new_bet
            next_state["bet_size"] = new_bet
            ev = (new_pot * state["hero_strength"] + simulate_strategy_tree(next_state, model, depth+1, max_depth, ev_trace)) * float(pred_probs[i]) - new_bet
        evs[action] = ev

    best_action = max(evs, key=evs.get)
    if ev_trace is not None:
        ev_trace.append((depth, best_action, float(evs[best_action]), [float(p) for p in pred_probs.tolist()]))
    return evs[best_action]

# --- Treys Hand Strength ---
def estimate_hand_strength(hole_cards_str, board_cards_str):
    if not USE_TREYS or not hole_cards_str:
        return 0.5

    try:
        hole_cards = hole_cards_str.upper().split()
        board_cards = board_cards_str.upper().split() if board_cards_str else []
        if len(hole_cards) + len(board_cards) < 5:
            return 0.5
        hole_treys = [Card.new(c) for c in hole_cards]
        board_treys = [Card.new(c) for c in board_cards]
        score = evaluator.evaluate(board_treys, hole_treys)  # 1=best, 7462=worst
        return (7463 - score) / 7462.0
    except:
        return 0.5

# --- Load and Prepare ---
try:
    df = pd.read_json("processed_hands.json")
except FileNotFoundError:
    print("Warning: processed_hands.json not found. Using empty DataFrame.")
    df = pd.DataFrame()


required_columns = [
    "street_encoded", "position_encoded", "board_texture_encoded",
    "player_agg_freq_roll", "player_fold_freq_roll", "player_pass_freq_roll",
    "player_fold_freq", "hand_strength", "pot_size", "stack_to_pot_ratio",
    "effective_stack", "board_connectedness", "is_preflop_aggressor",
    "bet_size_to_pot_ratio", "prev_bet_size", "player_agg_freq"
]
for col in required_columns:
    if col not in df.columns:
        df[col] = 0.0

features = [
    "street_encoded", "pot_size", "position_encoded", "stack_to_pot_ratio",
    "effective_stack", "board_texture_encoded", "board_connectedness",
    "is_preflop_aggressor", "bet_size_to_pot_ratio", "prev_bet_size",
    "player_agg_freq", "player_agg_freq_roll", "player_fold_freq_roll",
    "player_pass_freq_roll", "player_fold_freq", "hand_strength"
]

X = df[features].fillna(0.0)
y = LabelEncoder().fit_transform(df.get("action", pd.Series(["cc"] * len(df))).astype(str))

with open("/Users/bennykuttler/Downloads/Poker Bot/action_model_phase2_retrained.pkl", "rb") as f:
    booster = pickle.load(f)

class XGBWrapper:
    def __init__(self, booster, feature_names):
        self.booster = booster
        self.feature_names = feature_names

    def predict(self, X_df):
        dmatrix = xgb.DMatrix(X_df[self.feature_names], feature_names=self.feature_names)
        return self.booster.predict(dmatrix)

model = XGBWrapper(booster, feature_names=features)

# --- CLI Prompt ---
def cli_bot():
    print("\n--- Live Poker Bot (CLI Mode) ---")
    pot_size = float(input("Pot size (BB): "))
    eff_stack = float(input("Effective stack (BB): "))
    bet_size = float(input("Current bet size (BB): "))
    hole_cards = input("Enter your hole cards (e.g. 'As Kd'): ").strip()
    board_cards = input("Enter board cards (e.g. '7h 9c 2d') or press Enter: ").strip()

    strength = estimate_hand_strength(hole_cards, board_cards)
    print(f"Estimated hand strength: {strength:.3f}")

    stack_to_pot = eff_stack / pot_size if pot_size else 1000.0

    state = {
        "street_encoded": 1,
        "pot_size": pot_size,
        "position_encoded": 0,
        "stack_to_pot_ratio": stack_to_pot,
        "effective_stack": eff_stack,
        "board_texture_encoded": 0,
        "board_connectedness": 0.5,
        "is_preflop_aggressor": 1,
        "bet_size_to_pot_ratio": bet_size / pot_size if pot_size else 0.0,
        "prev_bet_size": bet_size,
        "player_agg_freq": 0.3,
        "player_agg_freq_roll": 0.25,
        "player_fold_freq_roll": 0.3,
        "player_pass_freq_roll": 0.2,
        "player_fold_freq": 0.35,
        "hand_strength": strength,
        "hero_strength": strength,
        "bet_size": bet_size
    }

    ev_trace = []
    tree_ev = simulate_strategy_tree(state, model, depth=1, max_depth=3, ev_trace=ev_trace)
    print(f"\nExploitative EV (tree-simulated): {tree_ev:.2f}\n")

    depths, actions, ev_values, probs = zip(*ev_trace)
    plt.figure(figsize=(8, 4))
    plt.plot(depths, ev_values, marker='o')
    for i, txt in enumerate(actions):
        plt.annotate(f"{txt}\n{[round(p,2) for p in probs[i]]}", (depths[i], ev_values[i]))
    plt.title("Exploitative EV Tree (Action by Depth)")
    plt.xlabel("Depth")
    plt.ylabel("Expected Value")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    with open("ev_trace_log.json", "w") as f:
        json.dump([{
            "depth": int(d),
            "action": a,
            "ev": float(ev),
            "probs": [float(p) for p in pr]
        } for d, a, ev, pr in ev_trace], f, indent=2)
    print("EV trace saved to ev_trace_log.json\n")

if __name__ == "__main__":
    cli_bot()
